======================================================
Creating a graph and inserting elements into graph
======================================================
import java.util.*;
import java.io.*;
public class Main
{
    static class Edge{
        int src;
        int nbr;
        int wt;
        public Edge(int src,int nbr,int wt){
            this.src=src;
            this.nbr=nbr;
            this.wt=wt;
        }
    }
	public static void main(String[] args) throws Exception {
	   BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
	   int vertices=Integer.parseInt(br.readLine());
	   int edges=Integer.parseInt(br.readLine());
	   ArrayList<Edge>[] graph=new ArrayList[vertices];
	   for(int i=0;i<vertices;i++)
	   {
	       graph[i]=new ArrayList<>();
	   }
	   for(int i=0;i<edges;i++)
	   {
	       String parts[]=br.readLine().split(" ");
	       int v1=Integer.parseInt(parts[0]);
	       int v2=Integer.parseInt(parts[1]);
	       int wt=Integer.parseInt(parts[2]);
	       graph[v1].add(new Edge(v1,v2,wt));
	       graph[v2].add(new Edge(v2,v1,wt));
	   }
	   for (int i = 0; i < vertices; i++) {
    System.out.print(i + " -> ");
    for (Edge e : graph[i]) {
        System.out.print("[" + e.nbr + "@" + e.wt + "] ");
    }
    System.out.println();
}

	}
}
======================================
Has Path and print all paths
=====================================
import java.util.*;
import java.io.*;

public class Main {
    static class Edge {
        int src;
        int nbr;
        int wt;

        public Edge(int src, int nbr, int wt) {
            this.src = src;
            this.nbr = nbr;
            this.wt = wt;
        }
    }

    public static void printAllpaths(ArrayList<Edge>[] graph, int src, int dest, boolean visited[], String psf) {
        if (src == dest) {
            System.out.println(psf);
            return;
        }
        visited[src] = true;

        for (Edge edge : graph[src]) {
            if (!visited[edge.nbr]) {
                printAllpaths(graph, edge.nbr, dest, visited, psf + edge.nbr);
            }
        }

        visited[src] = false;
    }

    public static boolean hasPath(ArrayList<Edge>[] graph, int src, int dest, boolean visited[]) {
        if (src == dest) {
            return true;
        }

        visited[src] = true;

        for (Edge edge : graph[src]) {
            if (!visited[edge.nbr]) {
                boolean hasNbrPath = hasPath(graph, edge.nbr, dest, visited);
                if (hasNbrPath) {
                    return true;
                }
            }
        }

        return false;
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int vertices = Integer.parseInt(br.readLine());
        int edges = Integer.parseInt(br.readLine());

        ArrayList<Edge>[] graph = new ArrayList[vertices];
        for (int i = 0; i < vertices; i++) {
            graph[i] = new ArrayList<>();
        }

        for (int i = 0; i < edges; i++) {
            String[] parts = br.readLine().split(" ");
            int v1 = Integer.parseInt(parts[0]);
            int v2 = Integer.parseInt(parts[1]);
            int wt = Integer.parseInt(parts[2]);
            graph[v1].add(new Edge(v1, v2, wt));
            graph[v2].add(new Edge(v2, v1, wt));
        }

       

        // Sample call to check hasPath and printAllpaths
        int src = 0;
        int dest = 3;

        System.out.println("\nDoes path exist from " + src + " to " + dest + "?");
        boolean[] visited = new boolean[vertices];
        System.out.println(hasPath(graph, src, dest, visited));

        System.out.println("\nAll paths from " + src + " to " + dest + ":");
        boolean[] visitedForAllPaths = new boolean[vertices];
        printAllpaths(graph, src, dest, visitedForAllPaths, src + "");
    }
}
=====================================================
MUTISOLVER
======================================================
import java.util.*;
import java.io.*;
public class Main
{
    public static class Edge{
        int src;
        int nbr;
        int wt;
        public Edge(int src,int nbr,int wt){
            this.src=src;
            this.nbr=nbr;
            this.wt=wt;
        }
    }
    public static class Pair implements Comparable<Pair>{
        int wsf;
        String psf;
        Pair(int wsf,String psf)
        {
            this.wsf=wsf;
            this.psf=psf;
        }
        public int compareTo(Pair o)
        {
            return this.wsf-o.wsf;
        }
    }
    static String spath;
    static Integer SpathWt=Integer.MAX_VALUE;
    static String lpath;
    static Integer LpathWt=Integer.MIN_VALUE;
    static String cpath;
    static Integer CpathWt=Integer.MAX_VALUE;
    static String fpath;
    static Integer FpathWt=Integer.MIN_VALUE; 
    
    static PriorityQueue<Pair> pq=new PriorityQueue<>();
   public static void MultiSolver(ArrayList<Edge>[] graph , boolean visited[],int src,int dest,int criteria,int k ,String psf,int wsf)
   {
       if(src==dest)
       {
          if(SpathWt>wsf)
          {
              SpathWt=wsf;
              spath=psf;
          }
          if(LpathWt<wsf)
          {
              LpathWt=wsf;
              lpath=psf;
          }
          if(criteria<wsf && wsf<CpathWt)
          {
              CpathWt=wsf;
              cpath=psf;
          }
          if(criteria>wsf && wsf>FpathWt)
          {
              FpathWt=wsf;
              fpath=psf;
          }
          if(pq.size()<k)
          {
              pq.add(new Pair(wsf,psf));
          }
          else{
              if(wsf>pq.peek().wsf){
                  pq.remove();
                  pq.add(new Pair(wsf,psf));
              }
          }
           return;
       }
       visited[src]=true;
       for(Edge e:graph[src])
       {
           if(!visited[e.nbr])
           {
               MultiSolver(graph,visited,e.nbr,dest,criteria,k,psf+e.nbr,wsf+e.wt);
           }
       }
       visited[src]=false;
   }
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		
		int vertices=Integer.parseInt(br.readLine());
		int edges=Integer.parseInt(br.readLine());
		
		ArrayList<Edge>[] graph=new ArrayList[vertices];
		
		for(int i=0;i<vertices;i++)
		{
		    graph[i]=new ArrayList<>();
		}
		for(int i=0;i<edges;i++)
		{
		    String parts[]=br.readLine().split(" ");
		    int v1=Integer.parseInt(parts[0]);
		    int v2=Integer.parseInt(parts[1]);
		    int wt=Integer.parseInt(parts[2]);
		    graph[v1].add(new Edge(v1,v2,wt));
		    graph[v2].add(new Edge(v2,v1,wt));
		}
			for(int i=0;i<vertices;i++)
		{
		    System.out.print("vertex "+i +"-> ");
		for(Edge e:graph[i])
		{
		    System.out.print("[ "+ e.src +" -" + e.nbr +" @ "+ e.wt +" ]");
		}
		 System.out.println(); 
		}
		
		System.out.println("Enter source, destination, criteria, and k:");
int src = Integer.parseInt(br.readLine());
int dest = Integer.parseInt(br.readLine());
int criteria = Integer.parseInt(br.readLine());
int k = Integer.parseInt(br.readLine());

boolean[] visited = new boolean[vertices];
MultiSolver(graph, visited, src, dest, criteria, k, "" + src, 0);

System.out.println("Smallest Path = " + spath + "@" + SpathWt);
System.out.println("Largest Path = " + lpath + "@" + LpathWt);
System.out.println("Just Larger Path than " + criteria + " = " + cpath + "@" + CpathWt);
System.out.println("Just Smaller Path than " + criteria + " = " + fpath + "@" + FpathWt);

System.out.println(k + "th largest path = " + pq.peek().psf + "@" + pq.peek().wsf);

	}
}
================================
Get connected components in a graph
=================================
import java.util.*;
import java.io.*;
public class Main
{
    public static class Edge{
        int src;
        int nbr;
        int wt;
        public Edge(int src,int nbr,int wt){
            this.src=src;
            this.nbr=nbr;
            this.wt=wt;
        }
    }
   public static void drawTreeAndGenerate(ArrayList<Edge>[] graph,boolean visited[],ArrayList<Integer> list,int src)
   {
       visited[src]=true;
       list.add(src);
       for(Edge e: graph[src])
       {
           if(!visited[e.nbr])
           {
                drawTreeAndGenerate(graph,visited,list,e.nbr);
           }
       }
   }
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		
		int vertices=Integer.parseInt(br.readLine());
		int edges=Integer.parseInt(br.readLine());
		
		ArrayList<Edge>[] graph=new ArrayList[vertices];
		
		for(int i=0;i<vertices;i++)
		{
		    graph[i]=new ArrayList<>();
		}
		for(int i=0;i<edges;i++)
		{
		    String parts[]=br.readLine().split(" ");
		    int v1=Integer.parseInt(parts[0]);
		    int v2=Integer.parseInt(parts[1]);
		    int wt=Integer.parseInt(parts[2]);
		    graph[v1].add(new Edge(v1,v2,wt));
		    graph[v2].add(new Edge(v2,v1,wt));
		}
		ArrayList<ArrayList<Integer>> ans=new ArrayList<>();
		boolean visited[]=new boolean[vertices];
	    for(int i=0;i<vertices;i++)
	    {
	        if(!visited[i])
	        {
	            ArrayList<Integer> list=new ArrayList<>();
	        drawTreeAndGenerate(graph,visited,list,i);
	         ans.add(list);
	        }
	       
	    }
	    System.out.print(ans);
	}
}
=========================================================
Is graph Connected?
==============================================================
/******************************************************************************

                            Online Java Compiler.
                Code, Compile, Run and Debug java program online.
Write your code in this editor and press "Run" button to execute it.

*******************************************************************************/
import java.util.*;
import java.io.*;
public class Main
{
    public static class Edge{
        int src;
        int wt;
        int nbr;
        public Edge(int src,int nbr,int wt)
        {
            this.src=src;
            this.wt=wt;
            this.nbr=nbr;
        }
    }
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		
		int vertices=Integer.parseInt(br.readLine());
		int edges=Integer.parseInt(br.readLine());
		ArrayList<Edge>[] graph=new ArrayList[vertices];
		
		for(int i=0;i<vertices;i++)
		{
		    graph[i]=new ArrayList<>();
		}
		for(int i=0;i<edges;i++)
		{
		    String paths[]=br.readLine().split(" ");
		    
		    int v1=Integer.parseInt(paths[0]);
		    int v2=Integer.parseInt(paths[1]);
		    int wt=Integer.parseInt(paths[2]);
		    
		    graph[v1].add(new Edge(v1,v2,wt));
		    graph[v2].add(new Edge(v2,v1,wt));
		}
		boolean visited[]=new boolean[vertices];
		int cnt=0;
		for(int i=0;i<vertices;i++)
		{
		    if(!visited[i])
		    {
		        ConnectedComponents( graph,visited,i);
		        cnt++;
		    }
		}
		if(cnt<=1)
		{
		    System.out.print("connected graph");
		}
		else{
		    System.out.print("unconnected graph");
		}
	}
	public static void ConnectedComponents(ArrayList<Edge>[] graph,boolean visited[],int src)
	{
	    visited[src]=true;
	    for(Edge e:graph[src])
	    {
	        if(!visited[e.nbr])
	        {
	            ConnectedComponents( graph,visited,e.nbr);
	        }
	    }
	}
}
=================================================
No of islands
===========================================
public class Main
{
	public static void main(String[] args) {
	   int[][] arr = {
    {1, 1, 0, 0, 0},
    {1, 1, 0, 0, 0},
    {0, 0, 1, 0, 0},
    {0, 0, 0, 1, 1}
        };
       boolean visited[][]=new boolean[arr.length][arr[0].length];
       int cnt=0;
       for(int i=0;i<arr.length;i++)
       {
           for(int j=0;j<arr[0].length;j++)
           {
               if(arr[i][j]==0 && !visited[i][j])
               {
                   findConnectComponent(arr,visited,i,j);
                   cnt++;
               }
           }
       }
       System.out.print("No of islands "+ cnt);
	}
	public static void findConnectComponent(int arr[][],boolean visited[][],int i,int j)
	{
	    if(i<0 || j<0 || i>=arr.length|| j>=arr[0].length || visited[i][j]==true || arr[i][j]==1 )
	    {
	        return;
	    }
	    visited[i][j]=true;
	    findConnectComponent(arr,visited,i+1,j);
	    findConnectComponent(arr,visited,i,j+1);
	    findConnectComponent(arr,visited,i-1,j);
	    findConnectComponent(arr,visited,i,j-1);
	}
}
========================================
Friend Pair islands
=======================================
import java.util.*;

public class Main {
    public static void main(String[] args) {
        int[][] arr = {
            {1, 1, 0, 0, 0},
            {1, 1, 0, 0, 0},
            {0, 0, 1, 0, 0},
            {0, 0, 0, 1, 1}
        };

        boolean[][] visited = new boolean[arr.length][arr[0].length];
        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        int cnt = 0;

        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[0].length; j++) {
                if (arr[i][j] == 0 && !visited[i][j]) {  // 0 is land
                    ArrayList<Integer> list = new ArrayList<>();
                    findConnectedComponent(arr, visited, i, j, list);
                    cnt++;
                    ans.add(list);
                }
            }
        }

        System.out.println("Number of islands (connected 0s): " + cnt);
        perfectFriend(ans);
    }

    public static void perfectFriend(ArrayList<ArrayList<Integer>> ans) {
        int total = 0;
        for (int i = 0; i < ans.size(); i++) {
            for (int j = i + 1; j < ans.size(); j++) {
                int cnt1 = ans.get(i).size();
                int cnt2 = ans.get(j).size();
                total += cnt1 * cnt2; // combinations of one from each group
            }
        }
        System.out.println("Total friend pairs across islands: " + total);
    }

    public static void findConnectedComponent(int[][] arr, boolean[][] visited, int i, int j, ArrayList<Integer> list) {
        if (i < 0 || j < 0 || i >= arr.length || j >= arr[0].length || visited[i][j] || arr[i][j] == 1) {
            return;
        }

        visited[i][j] = true;
        list.add(arr[i][j]);

        // Explore 4 directions
        findConnectedComponent(arr, visited, i + 1, j, list);
        findConnectedComponent(arr, visited, i - 1, j, list);
        findConnectedComponent(arr, visited, i, j + 1, list);
        findConnectedComponent(arr, visited, i, j - 1, list);
    }
}

