======================================================
Creating a graph and inserting elements into graph
======================================================
import java.util.*;
import java.io.*;
public class Main
{
    static class Edge{
        int src;
        int nbr;
        int wt;
        public Edge(int src,int nbr,int wt){
            this.src=src;
            this.nbr=nbr;
            this.wt=wt;
        }
    }
	public static void main(String[] args) throws Exception {
	   BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
	   int vertices=Integer.parseInt(br.readLine());
	   int edges=Integer.parseInt(br.readLine());
	   ArrayList<Edge>[] graph=new ArrayList[vertices];
	   for(int i=0;i<vertices;i++)
	   {
	       graph[i]=new ArrayList<>();
	   }
	   for(int i=0;i<edges;i++)
	   {
	       String parts[]=br.readLine().split(" ");
	       int v1=Integer.parseInt(parts[0]);
	       int v2=Integer.parseInt(parts[1]);
	       int wt=Integer.parseInt(parts[2]);
	       graph[v1].add(new Edge(v1,v2,wt));
	       graph[v2].add(new Edge(v2,v1,wt));
	   }
	   for (int i = 0; i < vertices; i++) {
    System.out.print(i + " -> ");
    for (Edge e : graph[i]) {
        System.out.print("[" + e.nbr + "@" + e.wt + "] ");
    }
    System.out.println();
}

	}
}
======================================
Has Path and print all paths
=====================================
import java.util.*;
import java.io.*;

public class Main {
    static class Edge {
        int src;
        int nbr;
        int wt;

        public Edge(int src, int nbr, int wt) {
            this.src = src;
            this.nbr = nbr;
            this.wt = wt;
        }
    }

    public static void printAllpaths(ArrayList<Edge>[] graph, int src, int dest, boolean visited[], String psf) {
        if (src == dest) {
            System.out.println(psf);
            return;
        }
        visited[src] = true;

        for (Edge edge : graph[src]) {
            if (!visited[edge.nbr]) {
                printAllpaths(graph, edge.nbr, dest, visited, psf + edge.nbr);
            }
        }

        visited[src] = false;
    }

    public static boolean hasPath(ArrayList<Edge>[] graph, int src, int dest, boolean visited[]) {
        if (src == dest) {
            return true;
        }

        visited[src] = true;

        for (Edge edge : graph[src]) {
            if (!visited[edge.nbr]) {
                boolean hasNbrPath = hasPath(graph, edge.nbr, dest, visited);
                if (hasNbrPath) {
                    return true;
                }
            }
        }

        return false;
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int vertices = Integer.parseInt(br.readLine());
        int edges = Integer.parseInt(br.readLine());

        ArrayList<Edge>[] graph = new ArrayList[vertices];
        for (int i = 0; i < vertices; i++) {
            graph[i] = new ArrayList<>();
        }

        for (int i = 0; i < edges; i++) {
            String[] parts = br.readLine().split(" ");
            int v1 = Integer.parseInt(parts[0]);
            int v2 = Integer.parseInt(parts[1]);
            int wt = Integer.parseInt(parts[2]);
            graph[v1].add(new Edge(v1, v2, wt));
            graph[v2].add(new Edge(v2, v1, wt));
        }

       

        // Sample call to check hasPath and printAllpaths
        int src = 0;
        int dest = 3;

        System.out.println("\nDoes path exist from " + src + " to " + dest + "?");
        boolean[] visited = new boolean[vertices];
        System.out.println(hasPath(graph, src, dest, visited));

        System.out.println("\nAll paths from " + src + " to " + dest + ":");
        boolean[] visitedForAllPaths = new boolean[vertices];
        printAllpaths(graph, src, dest, visitedForAllPaths, src + "");
    }
}
=====================================================
MUTISOLVER
======================================================
import java.util.*;
import java.io.*;
public class Main
{
    public static class Edge{
        int src;
        int nbr;
        int wt;
        public Edge(int src,int nbr,int wt){
            this.src=src;
            this.nbr=nbr;
            this.wt=wt;
        }
    }
    public static class Pair implements Comparable<Pair>{
        int wsf;
        String psf;
        Pair(int wsf,String psf)
        {
            this.wsf=wsf;
            this.psf=psf;
        }
        public int compareTo(Pair o)
        {
            return this.wsf-o.wsf;
        }
    }
    static String spath;
    static Integer SpathWt=Integer.MAX_VALUE;
    static String lpath;
    static Integer LpathWt=Integer.MIN_VALUE;
    static String cpath;
    static Integer CpathWt=Integer.MAX_VALUE;
    static String fpath;
    static Integer FpathWt=Integer.MIN_VALUE; 
    
    static PriorityQueue<Pair> pq=new PriorityQueue<>();
   public static void MultiSolver(ArrayList<Edge>[] graph , boolean visited[],int src,int dest,int criteria,int k ,String psf,int wsf)
   {
       if(src==dest)
       {
          if(SpathWt>wsf)
          {
              SpathWt=wsf;
              spath=psf;
          }
          if(LpathWt<wsf)
          {
              LpathWt=wsf;
              lpath=psf;
          }
          if(criteria<wsf && wsf<CpathWt)
          {
              CpathWt=wsf;
              cpath=psf;
          }
          if(criteria>wsf && wsf>FpathWt)
          {
              FpathWt=wsf;
              fpath=psf;
          }
          if(pq.size()<k)
          {
              pq.add(new Pair(wsf,psf));
          }
          else{
              if(wsf>pq.peek().wsf){
                  pq.remove();
                  pq.add(new Pair(wsf,psf));
              }
          }
           return;
       }
       visited[src]=true;
       for(Edge e:graph[src])
       {
           if(!visited[e.nbr])
           {
               MultiSolver(graph,visited,e.nbr,dest,criteria,k,psf+e.nbr,wsf+e.wt);
           }
       }
       visited[src]=false;
   }
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		
		int vertices=Integer.parseInt(br.readLine());
		int edges=Integer.parseInt(br.readLine());
		
		ArrayList<Edge>[] graph=new ArrayList[vertices];
		
		for(int i=0;i<vertices;i++)
		{
		    graph[i]=new ArrayList<>();
		}
		for(int i=0;i<edges;i++)
		{
		    String parts[]=br.readLine().split(" ");
		    int v1=Integer.parseInt(parts[0]);
		    int v2=Integer.parseInt(parts[1]);
		    int wt=Integer.parseInt(parts[2]);
		    graph[v1].add(new Edge(v1,v2,wt));
		    graph[v2].add(new Edge(v2,v1,wt));
		}
			for(int i=0;i<vertices;i++)
		{
		    System.out.print("vertex "+i +"-> ");
		for(Edge e:graph[i])
		{
		    System.out.print("[ "+ e.src +" -" + e.nbr +" @ "+ e.wt +" ]");
		}
		 System.out.println(); 
		}
		
		System.out.println("Enter source, destination, criteria, and k:");
int src = Integer.parseInt(br.readLine());
int dest = Integer.parseInt(br.readLine());
int criteria = Integer.parseInt(br.readLine());
int k = Integer.parseInt(br.readLine());

boolean[] visited = new boolean[vertices];
MultiSolver(graph, visited, src, dest, criteria, k, "" + src, 0);

System.out.println("Smallest Path = " + spath + "@" + SpathWt);
System.out.println("Largest Path = " + lpath + "@" + LpathWt);
System.out.println("Just Larger Path than " + criteria + " = " + cpath + "@" + CpathWt);
System.out.println("Just Smaller Path than " + criteria + " = " + fpath + "@" + FpathWt);

System.out.println(k + "th largest path = " + pq.peek().psf + "@" + pq.peek().wsf);

	}
}
================================
Get connected components in a graph
=================================
import java.util.*;
import java.io.*;
public class Main
{
    public static class Edge{
        int src;
        int nbr;
        int wt;
        public Edge(int src,int nbr,int wt){
            this.src=src;
            this.nbr=nbr;
            this.wt=wt;
        }
    }
   public static void drawTreeAndGenerate(ArrayList<Edge>[] graph,boolean visited[],ArrayList<Integer> list,int src)
   {
       visited[src]=true;
       list.add(src);
       for(Edge e: graph[src])
       {
           if(!visited[e.nbr])
           {
                drawTreeAndGenerate(graph,visited,list,e.nbr);
           }
       }
   }
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		
		int vertices=Integer.parseInt(br.readLine());
		int edges=Integer.parseInt(br.readLine());
		
		ArrayList<Edge>[] graph=new ArrayList[vertices];
		
		for(int i=0;i<vertices;i++)
		{
		    graph[i]=new ArrayList<>();
		}
		for(int i=0;i<edges;i++)
		{
		    String parts[]=br.readLine().split(" ");
		    int v1=Integer.parseInt(parts[0]);
		    int v2=Integer.parseInt(parts[1]);
		    int wt=Integer.parseInt(parts[2]);
		    graph[v1].add(new Edge(v1,v2,wt));
		    graph[v2].add(new Edge(v2,v1,wt));
		}
		ArrayList<ArrayList<Integer>> ans=new ArrayList<>();
		boolean visited[]=new boolean[vertices];
	    for(int i=0;i<vertices;i++)
	    {
	        if(!visited[i])
	        {
	            ArrayList<Integer> list=new ArrayList<>();
	        drawTreeAndGenerate(graph,visited,list,i);
	         ans.add(list);
	        }
	       
	    }
	    System.out.print(ans);
	}
}
=========================================================
Is graph Connected?
==============================================================
/******************************************************************************

                            Online Java Compiler.
                Code, Compile, Run and Debug java program online.
Write your code in this editor and press "Run" button to execute it.

*******************************************************************************/
import java.util.*;
import java.io.*;
public class Main
{
    public static class Edge{
        int src;
        int wt;
        int nbr;
        public Edge(int src,int nbr,int wt)
        {
            this.src=src;
            this.wt=wt;
            this.nbr=nbr;
        }
    }
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		
		int vertices=Integer.parseInt(br.readLine());
		int edges=Integer.parseInt(br.readLine());
		ArrayList<Edge>[] graph=new ArrayList[vertices];
		
		for(int i=0;i<vertices;i++)
		{
		    graph[i]=new ArrayList<>();
		}
		for(int i=0;i<edges;i++)
		{
		    String paths[]=br.readLine().split(" ");
		    
		    int v1=Integer.parseInt(paths[0]);
		    int v2=Integer.parseInt(paths[1]);
		    int wt=Integer.parseInt(paths[2]);
		    
		    graph[v1].add(new Edge(v1,v2,wt));
		    graph[v2].add(new Edge(v2,v1,wt));
		}
		boolean visited[]=new boolean[vertices];
		int cnt=0;
		for(int i=0;i<vertices;i++)
		{
		    if(!visited[i])
		    {
		        ConnectedComponents( graph,visited,i);
		        cnt++;
		    }
		}
		if(cnt<=1)
		{
		    System.out.print("connected graph");
		}
		else{
		    System.out.print("unconnected graph");
		}
	}
	public static void ConnectedComponents(ArrayList<Edge>[] graph,boolean visited[],int src)
	{
	    visited[src]=true;
	    for(Edge e:graph[src])
	    {
	        if(!visited[e.nbr])
	        {
	            ConnectedComponents( graph,visited,e.nbr);
	        }
	    }
	}
}
=================================================
No of islands
===========================================
public class Main
{
	public static void main(String[] args) {
	   int[][] arr = {
    {1, 1, 0, 0, 0},
    {1, 1, 0, 0, 0},
    {0, 0, 1, 0, 0},
    {0, 0, 0, 1, 1}
        };
       boolean visited[][]=new boolean[arr.length][arr[0].length];
       int cnt=0;
       for(int i=0;i<arr.length;i++)
       {
           for(int j=0;j<arr[0].length;j++)
           {
               if(arr[i][j]==0 && !visited[i][j])
               {
                   findConnectComponent(arr,visited,i,j);
                   cnt++;
               }
           }
       }
       System.out.print("No of islands "+ cnt);
	}
	public static void findConnectComponent(int arr[][],boolean visited[][],int i,int j)
	{
	    if(i<0 || j<0 || i>=arr.length|| j>=arr[0].length || visited[i][j]==true || arr[i][j]==1 )
	    {
	        return;
	    }
	    visited[i][j]=true;
	    findConnectComponent(arr,visited,i+1,j);
	    findConnectComponent(arr,visited,i,j+1);
	    findConnectComponent(arr,visited,i-1,j);
	    findConnectComponent(arr,visited,i,j-1);
	}
}
========================================
Friend Pair islands
=======================================
import java.util.*;

public class Main {
    public static void main(String[] args) {
        int[][] arr = {
            {1, 1, 0, 0, 0},
            {1, 1, 0, 0, 0},
            {0, 0, 1, 0, 0},
            {0, 0, 0, 1, 1}
        };

        boolean[][] visited = new boolean[arr.length][arr[0].length];
        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        int cnt = 0;

        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[0].length; j++) {
                if (arr[i][j] == 0 && !visited[i][j]) {  // 0 is land
                    ArrayList<Integer> list = new ArrayList<>();
                    findConnectedComponent(arr, visited, i, j, list);
                    cnt++;
                    ans.add(list);
                }
            }
        }

        System.out.println("Number of islands (connected 0s): " + cnt);
        perfectFriend(ans);
    }

    public static void perfectFriend(ArrayList<ArrayList<Integer>> ans) {
        int total = 0;
        for (int i = 0; i < ans.size(); i++) {
            for (int j = i + 1; j < ans.size(); j++) {
                int cnt1 = ans.get(i).size();
                int cnt2 = ans.get(j).size();
                total += cnt1 * cnt2; // combinations of one from each group
            }
        }
        System.out.println("Total friend pairs across islands: " + total);
    }

    public static void findConnectedComponent(int[][] arr, boolean[][] visited, int i, int j, ArrayList<Integer> list) {
        if (i < 0 || j < 0 || i >= arr.length || j >= arr[0].length || visited[i][j] || arr[i][j] == 1) {
            return;
        }

        visited[i][j] = true;
        list.add(arr[i][j]);

        // Explore 4 directions
        findConnectedComponent(arr, visited, i + 1, j, list);
        findConnectedComponent(arr, visited, i - 1, j, list);
        findConnectedComponent(arr, visited, i, j + 1, list);
        findConnectedComponent(arr, visited, i, j - 1, list);
    }
}
=====================================
Hamilton Cycle
========================================
import java.util.*;
import java.io.*;

public class Main {
    static class Edge {
        int src, nbr, wt;
        public Edge(int src, int nbr, int wt) {
            this.src = src;
            this.nbr = nbr;
            this.wt = wt;
        }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int vertices = Integer.parseInt(br.readLine());
        int edges = Integer.parseInt(br.readLine());
        ArrayList<Edge>[] graph = new ArrayList[vertices];
        
        for (int i = 0; i < vertices; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int i = 0; i < edges; i++) {
            String[] parts = br.readLine().split(" ");
            int v1 = Integer.parseInt(parts[0]);
            int v2 = Integer.parseInt(parts[1]);
            int wt = Integer.parseInt(parts[2]);
            graph[v1].add(new Edge(v1, v2, wt));
            graph[v2].add(new Edge(v2, v1, wt));
        }
        HashSet<Integer> visited = new HashSet<>();
        hamiltonGraph(graph, visited, 0, 0 + "", 0);
    }

    public static void hamiltonGraph(ArrayList<Edge>[] graph, HashSet<Integer> visited, int src, String psf, int Osrc) {
        if (visited.size() == graph.length - 1) {
            System.out.print(psf);
            boolean closingEdgeFound = false;
            for (Edge e : graph[src]) {
                if (e.nbr == Osrc) { // ✅ fixed check
                    closingEdgeFound = true;
                    break;
                }
            }
            if (closingEdgeFound) {
                System.out.print("*");
            } else {
                System.out.print("-");
            }
            System.out.println();
            return;
        }

        visited.add(src);
        for (Edge e : graph[src]) {
            if (!visited.contains(e.nbr)) {
                hamiltonGraph(graph, visited, e.nbr, psf + e.nbr, Osrc);
            }
        }
        visited.remove(src); // ✅ backtracking
    }
}
==============================
Breadth first search
================================
import java.util.*;
import java.io.*;
public class Main
{
    static class Edge{
        int src;
        int nbr;
        int wt;
        public Edge(int src,int nbr,int wt){
            this.src=src;
            this.nbr=nbr;
            this.wt=wt;
        }
    }
     static class Pair {
        int v;
        String psf;
        public Pair(int v, String psf) { // ✅ String type
            this.v = v;
            this.psf = psf;
        }
    }
	public static void main(String[] args) throws Exception {
	   BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
	   int vertices=Integer.parseInt(br.readLine());
	   int edges=Integer.parseInt(br.readLine());
	   ArrayList<Edge>[] graph=new ArrayList[vertices];
	   for(int i=0;i<vertices;i++)
	   {
	       graph[i]=new ArrayList<>();
	   }
	   for(int i=0;i<edges;i++)
	   {
	       String parts[]=br.readLine().split(" ");
	       int v1=Integer.parseInt(parts[0]);
	       int v2=Integer.parseInt(parts[1]);
	       int wt=Integer.parseInt(parts[2]);
	       graph[v1].add(new Edge(v1,v2,wt));
	       graph[v2].add(new Edge(v2,v1,wt));
	   }
	 

    
    boolean visited[] =new boolean[vertices];
       Queue<Pair> q = new ArrayDeque<>(); // ✅ inside main()
        q.add(new Pair(0, "0"));
        while(q.size()>0)
        {
            Pair remove=q.remove();
            if(visited[remove.v]){
                continue;
            }
            visited[remove.v]=true;
            System.out.println(remove.v+" @ "+ remove.psf);
            for(Edge e : graph[remove.v])
            {
                if(!visited[e.nbr])
                {
                   
                    q.add(new Pair(e.nbr,remove.psf+e.nbr));
                }
            }
        }

	}
}
=========================
Is cycle using BFS?
==========================
import java.util.*;
import java.io.*;
public class Main
{
    static class Edge{
        int src;
        int nbr;
        int wt;
        public Edge(int src,int nbr,int wt){
            this.src=src;
            this.nbr=nbr;
            this.wt=wt;
        }
    }
  
	public static void main(String[] args) throws Exception {
	   BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
	   int vertices=Integer.parseInt(br.readLine());
	   int edges=Integer.parseInt(br.readLine());
	   ArrayList<Edge>[] graph=new ArrayList[vertices];
	   for(int i=0;i<vertices;i++)
	   {
	       graph[i]=new ArrayList<>();
	   }
	   for(int i=0;i<edges;i++)
	   {
	       String parts[]=br.readLine().split(" ");
	       int v1=Integer.parseInt(parts[0]);
	       int v2=Integer.parseInt(parts[1]);
	       int wt=Integer.parseInt(parts[2]);
	       graph[v1].add(new Edge(v1,v2,wt));
	       graph[v2].add(new Edge(v2,v1,wt));
	   }
	 boolean visited[]=new boolean[vertices];
	 
	 for(int i=0;i<vertices;i++)
	 {
	     if(!visited[i])
	     {
	         boolean cycle=isCycle(graph,i,visited);
	         if(cycle)
	         {
	             System.out.print("Yes cycle");
	             return;
	         }
	     }
	 }
	 System.out.print("No cycle");
	}
	public static boolean isCycle(ArrayList<Edge>[] graph,int src,boolean visited[])
	{
	    Queue<Integer> q=new ArrayDeque<>();
	    q.add(src);
	    while(q.size()>0)
	    {
	        int rem=q.remove();
	      
	            if(visited[rem])
	            {
	                return true;
	            }
	            visited[rem]=true;
	         for(Edge e:graph[rem])
	        {
	            if(!visited[e.nbr])
	            {
	                q.add(e.nbr);
	            }
	        }
	        
	    }
	    return false;
	}
}
==================================
Bipartite Graph 
===================================
import java.util.*;
import java.io.*;
public class Main
{
    static class Edge{
        int src;
        int nbr;
        int wt;
        public Edge(int src,int nbr,int wt){
            this.src=src;
            this.nbr=nbr;
            this.wt=wt;
        }
    }
    public static class Pair{
        int v;
        int level;
        public Pair(int v,int level)
        {
            this.v=v;
            this.level=level;
        }
    }
	public static void main(String[] args) throws Exception {
	   BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
	   int vertices=Integer.parseInt(br.readLine());
	   int edges=Integer.parseInt(br.readLine());
	   ArrayList<Edge>[] graph=new ArrayList[vertices];
	   for(int i=0;i<vertices;i++)
	   {
	       graph[i]=new ArrayList<>();
	   }
	   for(int i=0;i<edges;i++)
	   {
	       String parts[]=br.readLine().split(" ");
	       int v1=Integer.parseInt(parts[0]);
	       int v2=Integer.parseInt(parts[1]);
	       int wt=Integer.parseInt(parts[2]);
	       graph[v1].add(new Edge(v1,v2,wt));
	       graph[v2].add(new Edge(v2,v1,wt));
	   }
	  
        int visited[]=new int[vertices];
        Arrays.fill(visited,-1);
        boolean flag=true;
        for(int i=0;i<vertices;i++){
            if(visited[i]==-1)
            {
              flag= bipartite(i,graph,visited);
            }
        }
        if(flag)
        {
            System.out.println("bipartite graph");
        }
        else{
            System.out.println("Not a bipartite graph");
        }
 
}
    
    public static boolean bipartite(int src,ArrayList<Edge>[] graph,int visited[])
    {
        Queue<Pair> q=new ArrayDeque<>();
        q.add(new Pair(src,0));
        while(q.size()>0)
        {
            Pair rem= q.remove();
            if(visited[rem.v]!=-1)
            {
                if(visited[rem.v]!=rem.level)
                {
                    return false;
                }
            }
            else{
                visited[rem.v]=rem.level;
                for(Edge e: graph[rem.v])
                {
                    if(visited[e.nbr]==-1)
                    {
                    q.add(new Pair(e.nbr,rem.level+1));
                    }
                }
            }
        }
        return true;
    }

}
=======================================
Spreads Infection
=====================================
import java.util.*;
import java.io.*;
public class Main
{
    static class Edge{
        int src;
        int nbr;
        int wt;
        public Edge(int src,int nbr,int wt){
            this.src=src;
            this.nbr=nbr;
            this.wt=wt;
        }
    }
   public static class Pair{
        int v;
        int t;
        public Pair(int v,int t)
        {
            this.v=v;
            this.t=t;
        }
    }
  
	public static void main(String[] args) throws Exception {
	   BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
	   int vertices=Integer.parseInt(br.readLine());
	   int edges=Integer.parseInt(br.readLine());
	   ArrayList<Edge>[] graph=new ArrayList[vertices];
	   for(int i=0;i<vertices;i++)
	   {
	       graph[i]=new ArrayList<>();
	   }
	   for(int i=0;i<edges;i++)
	   {
	       String parts[]=br.readLine().split(" ");
	       int v1=Integer.parseInt(parts[0]);
	       int v2=Integer.parseInt(parts[1]);
	       int wt=Integer.parseInt(parts[2]);
	       graph[v1].add(new Edge(v1,v2,wt));
	       graph[v2].add(new Edge(v2,v1,wt));
	   }
	  
	  int src=0;
	  int time =3;
	  int visited[]=new int[vertices];
	 int cnt= SpreadInfection(src,time,graph,visited);
	 System.out.print(cnt);
}
  public static int SpreadInfection(int src,int time,ArrayList<Edge>[] graph,int visited[])
    {
        int cnt=0;
         Deque<Pair> q=new ArrayDeque<>();
         q.add(new Pair(src,1));
         while(!q.isEmpty())
         {
             Pair rem=q.remove();
              if (visited[rem.v] != 0) {
            continue; 
        }
             if (rem.t > time) break;

             cnt++;
                 visited[rem.v]=rem.t;
                 
                 for(Edge e:graph[rem.v])
                 {
                     if(visited[e.nbr]==0)
                     {
                         q.add(new Pair(e.nbr,rem.t+1));
                     }
                 }
             
            
         }
         return cnt;
    }

	}
===========================
Dijkstra Algorithm
==============================
import java.util.*;
import java.io.*;
public class Main
{
    static class Edge{
        int src;
        int nbr;
        int wt;
        public Edge(int src,int nbr,int wt){
            this.src=src;
            this.nbr=nbr;
            this.wt=wt;
        }
    }
    public static class Pair implements Comparable<Pair>{
        int v;
        String psf;
        int wsf;
        
        public Pair(int v,String psf,int wsf)
        {
            this.v=v;
            this.psf=psf;
            this.wsf=wsf;
        }
        public int compareTo(Pair o){
            return this.wsf-o.wsf;
        }
    }
	public static void main(String[] args) throws Exception {
	   BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
	   int vertices=Integer.parseInt(br.readLine());
	   int edges=Integer.parseInt(br.readLine());
	   ArrayList<Edge>[] graph=new ArrayList[vertices];
	   for(int i=0;i<vertices;i++)
	   {
	       graph[i]=new ArrayList<>();
	   }
	   for(int i=0;i<edges;i++)
	   {
	       String parts[]=br.readLine().split(" ");
	       int v1=Integer.parseInt(parts[0]);
	       int v2=Integer.parseInt(parts[1]);
	       int wt=Integer.parseInt(parts[2]);
	       graph[v1].add(new Edge(v1,v2,wt));
	       graph[v2].add(new Edge(v2,v1,wt));
	   }
	   
	   int src=Integer.parseInt(br.readLine());
	   boolean visited[]=new boolean[vertices];
	   PriorityQueue<Pair> pq=new PriorityQueue<>();
	   pq.add(new Pair(src,src+"",0));
	   while(!pq.isEmpty())
	   {
	       Pair rem=pq.remove();
	       if(visited[rem.v])
	       {
	           continue;
	       }
	       visited[rem.v]=true;
	       System.out.println(rem.v+" via "+rem.psf+" @ "+rem.wsf);
	       for(Edge e: graph[rem.v])
	       {
	           pq.add(new Pair(e.nbr,rem.psf+ " -> "+e.nbr,rem.wsf+e.wt));
	       }
	   }
	}
}
================================
prims Algoritm
===========================
import java.util.*;
import java.io.*;
public class Main
{
    static class Edge{
        int src;
        int nbr;
        int wt;
        public Edge(int src,int nbr,int wt){
            this.src=src;
            this.nbr=nbr;
            this.wt=wt;
        }
    }
    public static class Pair implements Comparable<Pair>{
        int v;
        int av;
        int wsf;
        
        public Pair(int v,int av,int wsf)
        {
            this.v=v;
            this.av=av;
            this.wsf=wsf;
        }
        public int compareTo(Pair o){
            return this.wsf-o.wsf;
        }
    }
	public static void main(String[] args) throws Exception {
	   BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
	   int vertices=Integer.parseInt(br.readLine());
	   int edges=Integer.parseInt(br.readLine());
	   ArrayList<Edge>[] graph=new ArrayList[vertices];
	   for(int i=0;i<vertices;i++)
	   {
	       graph[i]=new ArrayList<>();
	   }
	   for(int i=0;i<edges;i++)
	   {
	       String parts[]=br.readLine().split(" ");
	       int v1=Integer.parseInt(parts[0]);
	       int v2=Integer.parseInt(parts[1]);
	       int wt=Integer.parseInt(parts[2]);
	       graph[v1].add(new Edge(v1,v2,wt));
	       graph[v2].add(new Edge(v2,v1,wt));
	   }
	   
	   int src=Integer.parseInt(br.readLine());
	   boolean visited[]=new boolean[vertices];
	   PriorityQueue<Pair> pq=new PriorityQueue<>();
	   pq.add(new Pair(src,-1,0));
	   while(!pq.isEmpty())
	   {
	       Pair rem=pq.remove();
	       if(visited[rem.v])
	       {
	           continue;
	       }
	       visited[rem.v]=true;
	       if(rem.av!=-1){
	       System.out.println(rem.v+" - "+rem.av+" @ "+rem.wsf);
	       }
	       for(Edge e: graph[rem.v])
	       {
	           if(!visited[e.nbr]){
	           pq.add(new Pair(e.nbr,rem.v,e.wt));
	           }
	       }
	   }
	}
}

